# ===============================
# è§†é¢‘å·¥åŠ - GitHub Actions äº‘æ‰“åŒ…é…ç½®
# ===============================

name: Flutter Build APK
on:
  push:
    branches: [main, master]
  workflow_dispatch:

env:
  APP_NAME: "è§†é¢‘å·¥åŠ"
  FILE_NAME: "VideoCutter"

jobs:
  build:
    runs-on: ubuntu-latest
    
    env:
      LANG: "en_US.UTF-8"

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.19.0'
          channel: 'stable'

      # ã€å…³é”®ã€‘ä¸‹è½½ FFmpeg for Android (ä½¿ç”¨å¯é çš„ arthenica/ffmpeg-kit ä»“åº“)
      - name: Download FFmpeg Binary
        run: |
          echo "ğŸ“¦ ä¸‹è½½ FFmpeg for Android arm64..."
          mkdir -p assets/bin
          
          # ========================================
          # æ–¹æ¡ˆ1: ç›´æ¥ä» mobile-ffmpeg LTS ä¸‹è½½ (æœ€å¯é )
          # ========================================
          echo "ğŸ“¥ å°è¯•æ–¹æ¡ˆ1: mobile-ffmpeg LTS..."
          FFMPEG_LTS_URL="https://github.com/tanersener/mobile-ffmpeg/releases/download/v4.4.LTS/mobile-ffmpeg-min-gpl-4.4.LTS-android-main.aar"
          
          # ä¸‹è½½ AAR åŒ…å¹¶æå– arm64 äºŒè¿›åˆ¶
          curl -L -o mobile-ffmpeg.aar "$FFMPEG_LTS_URL" && {
            unzip -o mobile-ffmpeg.aar -d ffmpeg_extract 2>/dev/null || true
            
            # åœ¨ AAR ä¸­æŸ¥æ‰¾ arm64 äºŒè¿›åˆ¶
            find ffmpeg_extract -name "libffmpegkit.so" -path "*arm64*" | head -1 | xargs -I {} dirname {} > .lib_path
            LIB_PATH=$(cat .lib_path 2>/dev/null)
            
            if [ -n "$LIB_PATH" ] && [ -d "$LIB_PATH" ]; then
              echo "âœ… æ‰¾åˆ°åº“è·¯å¾„: $LIB_PATH"
              ls -la "$LIB_PATH"
            fi
          }
          
          # ========================================
          # æ–¹æ¡ˆ2: ä½¿ç”¨ BtbN/FFmpeg-Builds é™æ€æ„å»º
          # ========================================
          if [ ! -f "assets/bin/ffmpeg" ] || [ $(stat -c%s "assets/bin/ffmpeg" 2>/dev/null || echo 0) -lt 1000000 ]; then
            echo "ğŸ“¥ å°è¯•æ–¹æ¡ˆ2: BtbN FFmpeg é™æ€æ„å»º..."
            
            BTBN_URL="https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-linuxarm64-gpl.tar.xz"
            curl -L -o ffmpeg-build.tar.xz "$BTBN_URL" && {
              tar xf ffmpeg-build.tar.xz
              find . -path "*/bin/ffmpeg" -type f | head -1 | xargs -I {} cp {} assets/bin/ffmpeg
              find . -path "*/bin/ffprobe" -type f | head -1 | xargs -I {} cp {} assets/bin/ffprobe
            }
          fi
          
          # ========================================
          # æ–¹æ¡ˆ3: ä½¿ç”¨é¢„ç¼–è¯‘çš„ Android ç‹¬ç«‹äºŒè¿›åˆ¶
          # ========================================
          if [ ! -f "assets/bin/ffmpeg" ] || [ $(stat -c%s "assets/bin/ffmpeg" 2>/dev/null || echo 0) -lt 1000000 ]; then
            echo "ğŸ“¥ å°è¯•æ–¹æ¡ˆ3: FFmpeg Android ç‹¬ç«‹äºŒè¿›åˆ¶..."
            
            # ä» ApeironThan);é¢„ç¼–è¯‘çš„ Android é™æ€äºŒè¿›åˆ¶
            ANDROID_FFMPEG_URL="https://github.com/ApeironThanatos/ffmpeg-android-build/releases/download/n7.1/ffmpeg-android-arm64-v8a.zip"
            curl -L -o ffmpeg-android.zip "$ANDROID_FFMPEG_URL" && {
              unzip -o ffmpeg-android.zip -d ffmpeg_android_extract
              find ffmpeg_android_extract -name "ffmpeg" -type f | head -1 | xargs -I {} cp {} assets/bin/ffmpeg
              find ffmpeg_android_extract -name "ffprobe" -type f | head -1 | xargs -I {} cp {} assets/bin/ffprobe
            }
          fi
          
          # ========================================
          # æ–¹æ¡ˆ4: æœ€åå¤‡é€‰ - ä» eugeneware ä¸‹è½½
          # ========================================
          if [ ! -f "assets/bin/ffmpeg" ] || [ $(stat -c%s "assets/bin/ffmpeg" 2>/dev/null || echo 0) -lt 1000000 ]; then
            echo "ğŸ“¥ å°è¯•æ–¹æ¡ˆ4: eugeneware å¤‡é€‰æº..."
            
            EUGENE_URL="https://github.com/AerunWeb/ffmpeg-android-release/raw/main/ffmpeg-arm64-v8a"
            curl -L -o assets/bin/ffmpeg "$EUGENE_URL" 2>/dev/null || true
          fi
          
          # ========================================
          # è®¾ç½®æƒé™å¹¶éªŒè¯
          # ========================================
          chmod +x assets/bin/* 2>/dev/null || true
          
          echo ""
          echo "========================================="
          echo "âœ… FFmpeg ä¸‹è½½ç»“æœ:"
          ls -lh assets/bin/ || echo "âŒ assets/bin ç›®å½•ä¸å­˜åœ¨"
          echo "========================================="
          
          # æœ€ç»ˆæ£€æŸ¥
          if [ -f "assets/bin/ffmpeg" ]; then
            SIZE=$(stat -c%s "assets/bin/ffmpeg" 2>/dev/null || echo 0)
            echo "FFmpeg æ–‡ä»¶å¤§å°: $SIZE bytes ($(($SIZE / 1024 / 1024)) MB)"
            if [ "$SIZE" -lt 1000000 ]; then
              echo "âš ï¸ è­¦å‘Š: FFmpeg æ–‡ä»¶è¿‡å°ï¼Œå¯èƒ½ä¸‹è½½å¤±è´¥ï¼"
              echo "å°†ä½¿ç”¨ ffmpeg_kit_flutter æ’ä»¶ä½œä¸ºå¤‡é€‰..."
            else
              echo "âœ… FFmpeg ä¸‹è½½æˆåŠŸï¼"
            fi
          else
            echo "âŒ æ‰€æœ‰ä¸‹è½½æºå‡å¤±è´¥ï¼Œå°†ä½¿ç”¨ ffmpeg_kit_flutter æ’ä»¶"
          fi

      - name: Create Android Project
        run: |
          if [ ! -d "android" ]; then
            flutter create . --platforms android --project-name video_cutter
          fi

      - name: Change App Name
        run: |
          MANIFEST="android/app/src/main/AndroidManifest.xml"
          
          # ä¿®æ”¹ APP åç§°
          sed -i 's/android:label="[^"]*"/android:label="è§†é¢‘å·¥åŠ"/g' "$MANIFEST"
          
          # æ·»åŠ å­˜å‚¨æƒé™ (å¦‚æœä¸å­˜åœ¨)
          if ! grep -q "READ_EXTERNAL_STORAGE" "$MANIFEST"; then
            sed -i 's/<application/<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"\/>\n    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"\/>\n    <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"\/>\n    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO"\/>\n    <uses-permission android:name="android.permission.READ_MEDIA_AUDIO"\/>\n\n    <application/g' "$MANIFEST"
          fi
          
          # æ·»åŠ  requestLegacyExternalStorage (Android 10 å…¼å®¹)
          if ! grep -q "requestLegacyExternalStorage" "$MANIFEST"; then
            sed -i 's/<application/<application android:requestLegacyExternalStorage="true"/g' "$MANIFEST"
          fi
          
          echo "âœ… AndroidManifest.xml å·²æ›´æ–°"
          cat "$MANIFEST" | head -30

      - name: Fix Android Environment
        run: |
          sed -i 's/id "org.jetbrains.kotlin.android" version ".*"/id "org.jetbrains.kotlin.android" version "1.9.0"/g' android/settings.gradle
          sed -i "s/ext.kotlin_version = .*/ext.kotlin_version = '1.9.0'/g" android/build.gradle
          sed -i 's/minSdkVersion.*/minSdkVersion 21/g' android/app/build.gradle
          
          # ä¿®å¤ compileSdkVersion ä»¥æ”¯æŒæ–°æƒé™
          sed -i 's/compileSdkVersion.*/compileSdkVersion 33/g' android/app/build.gradle
          sed -i 's/targetSdkVersion.*/targetSdkVersion 33/g' android/app/build.gradle

      - name: Create Kotlin FFmpeg Bridge
        run: |
          KOTLIN_DIR="android/app/src/main/kotlin/com/example/video_cutter"
          mkdir -p "$KOTLIN_DIR"
          
          cat > "$KOTLIN_DIR/MainActivity.kt" << 'KOTLIN_EOF'
          package com.example.video_cutter

          import android.os.Bundle
          import android.util.Log
          import io.flutter.embedding.android.FlutterActivity
          import io.flutter.embedding.engine.FlutterEngine
          import io.flutter.plugin.common.MethodChannel
          import java.io.File
          import java.io.FileOutputStream

          class MainActivity : FlutterActivity() {
              private val CHANNEL = "com.videocutter/ffmpeg"
              private val TAG = "VideoCutter"
              private var ffmpegPath: String? = null
              private var ffprobePath: String? = null

              override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
                  super.configureFlutterEngine(flutterEngine)
                  
                  initFFmpegBinary()
                  
                  MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->
                      when (call.method) {
                          "cutVideo" -> {
                              val input = call.argument<String>("input") ?: ""
                              val output = call.argument<String>("output") ?: ""
                              val start = call.argument<String>("start") ?: "0"
                              val end = call.argument<String>("end") ?: "10"
                              
                              Log.d(TAG, "cutVideo: $input -> $output [$start - $end]")
                              
                              Thread {
                                  val success = runFFmpeg(listOf(
                                      "-y", "-ss", start, "-to", end,
                                      "-i", input, "-c", "copy",
                                      "-avoid_negative_ts", "1", output
                                  ))
                                  runOnUiThread { result.success(success) }
                              }.start()
                          }
                          "stitchVideos" -> {
                              val inputs = call.argument<List<String>>("inputs") ?: listOf()
                              val output = call.argument<String>("output") ?: ""
                              
                              Log.d(TAG, "stitchVideos: ${inputs.size} files -> $output")
                              
                              Thread {
                                  val success = stitchVideos(inputs, output)
                                  runOnUiThread { result.success(success) }
                              }.start()
                          }
                          "analyzeVideo" -> {
                              val path = call.argument<String>("path") ?: ""
                              Log.d(TAG, "analyzeVideo: $path")
                              
                              Thread {
                                  val info = analyzeVideo(path)
                                  runOnUiThread { result.success(info) }
                              }.start()
                          }
                          "isReady" -> {
                              val ready = ffmpegPath != null && 
                                         File(ffmpegPath!!).exists() && 
                                         File(ffmpegPath!!).length() > 1000000
                              Log.d(TAG, "isReady: $ready, path: $ffmpegPath")
                              result.success(ready)
                          }
                          "getFFmpegPath" -> result.success(ffmpegPath)
                          else -> result.notImplemented()
                      }
                  }
              }

              private fun initFFmpegBinary() {
                  try {
                      val binDir = File(filesDir, "bin")
                      binDir.mkdirs()
                      
                      listOf("ffmpeg", "ffprobe").forEach { name ->
                          val outFile = File(binDir, name)
                          Log.d(TAG, "Checking $name at ${outFile.absolutePath}")
                          
                          if (!outFile.exists() || outFile.length() < 1000000) {
                              Log.d(TAG, "Copying $name from assets...")
                              try {
                                  assets.open("bin/$name").use { input ->
                                      FileOutputStream(outFile).use { output ->
                                          val buffer = ByteArray(8192)
                                          var read: Int
                                          while (input.read(buffer).also { read = it } != -1) {
                                              output.write(buffer, 0, read)
                                          }
                                      }
                                  }
                                  outFile.setExecutable(true, false)
                                  Log.d(TAG, "$name copied, size: ${outFile.length()}")
                              } catch (e: Exception) {
                                  Log.e(TAG, "Failed to copy $name: ${e.message}")
                              }
                          }
                          
                          if (name == "ffmpeg") ffmpegPath = outFile.absolutePath
                          if (name == "ffprobe") ffprobePath = outFile.absolutePath
                      }
                      
                      Log.d(TAG, "FFmpeg init complete. Path: $ffmpegPath, Size: ${File(ffmpegPath ?: "").length()}")
                  } catch (e: Exception) {
                      Log.e(TAG, "initFFmpegBinary failed: ${e.message}")
                  }
              }

              private fun runFFmpeg(args: List<String>): Boolean {
                  val path = ffmpegPath ?: return false
                  val file = File(path)
                  if (!file.exists() || file.length() < 1000000) {
                      Log.e(TAG, "FFmpeg not available: ${file.length()} bytes")
                      return false
                  }
                  
                  return try {
                      val cmd = listOf(path) + args
                      Log.d(TAG, "Running: ${cmd.joinToString(" ")}")
                      
                      val process = ProcessBuilder(cmd)
                          .redirectErrorStream(true)
                          .start()
                      
                      val output = process.inputStream.bufferedReader().readText()
                      val exitCode = process.waitFor()
                      
                      Log.d(TAG, "Exit code: $exitCode")
                      if (exitCode != 0) Log.e(TAG, "Output: $output")
                      
                      exitCode == 0
                  } catch (e: Exception) {
                      Log.e(TAG, "runFFmpeg failed: ${e.message}")
                      false
                  }
              }

              private fun stitchVideos(inputs: List<String>, output: String): Boolean {
                  val path = ffmpegPath ?: return false
                  
                  return try {
                      val listFile = File(cacheDir, "concat_${System.currentTimeMillis()}.txt")
                      listFile.writeText(inputs.joinToString("\n") { "file '$it'" })
                      
                      val cmd = listOf(path, "-y", "-f", "concat", "-safe", "0", 
                                       "-i", listFile.absolutePath, "-c", "copy", output)
                      
                      Log.d(TAG, "Stitch cmd: ${cmd.joinToString(" ")}")
                      
                      val process = ProcessBuilder(cmd).redirectErrorStream(true).start()
                      val out = process.inputStream.bufferedReader().readText()
                      val exitCode = process.waitFor()
                      listFile.delete()
                      
                      Log.d(TAG, "Stitch exit: $exitCode")
                      exitCode == 0
                  } catch (e: Exception) {
                      Log.e(TAG, "stitchVideos failed: ${e.message}")
                      false
                  }
              }

              private fun analyzeVideo(path: String): Map<String, Any>? {
                  val probePath = ffprobePath ?: return null
                  
                  return try {
                      val cmd = listOf(probePath, "-v", "error", "-select_streams", "v:0",
                          "-show_entries", "stream=width,height,codec_name,r_frame_rate:format=duration",
                          "-of", "csv=p=0", path)
                      
                      val process = ProcessBuilder(cmd).redirectErrorStream(true).start()
                      val output = process.inputStream.bufferedReader().readText().trim()
                      process.waitFor()
                      
                      Log.d(TAG, "Probe output: $output")
                      
                      val parts = output.split(",")
                      if (parts.size >= 4) {
                          mapOf(
                              "codec" to parts[0],
                              "width" to (parts[1].toIntOrNull() ?: 0),
                              "height" to (parts[2].toIntOrNull() ?: 0),
                              "fps" to parts[3],
                              "duration" to (parts.getOrNull(4)?.toDoubleOrNull() ?: 0.0)
                          )
                      } else null
                  } catch (e: Exception) {
                      Log.e(TAG, "analyzeVideo failed: ${e.message}")
                      null
                  }
              }
          }
          KOTLIN_EOF

      - name: Install Dependencies
        run: flutter pub get

      - name: Generate Keystore
        run: |
          keytool -genkey -v -keystore upload-keystore.jks \
            -keyalg RSA -keysize 2048 -validity 10000 \
            -alias upload -dname "CN=Android, OU=Android, O=Android, L=Android, S=Android, C=US" \
            -storepass android -keypass android
          
          echo "storePassword=android" > android/key.properties
          echo "keyPassword=android" >> android/key.properties
          echo "keyAlias=upload" >> android/key.properties
          echo "storeFile=../../upload-keystore.jks" >> android/key.properties

      - name: Build APK
        run: flutter build apk --release --target-platform android-arm64

      - name: Check APK Size
        run: |
          SIZE=$(stat -c%s build/app/outputs/flutter-apk/app-release.apk)
          echo "APK size: $SIZE bytes ($(($SIZE / 1024 / 1024)) MB)"
          if [ "$SIZE" -lt 10000000 ]; then
            echo "âš ï¸ APK å¤ªå°ï¼ŒFFmpeg å¯èƒ½æ²¡æœ‰æ­£ç¡®æ‰“åŒ…"
          fi

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.FILE_NAME }}_Release
          path: build/app/outputs/flutter-apk/app-release.apk
